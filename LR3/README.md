# Лабораторная работа 3

### Задание
Выполнить следующие задания из набора заданий репозитория https://github.com/ververica/flink-training-exercises:

- RideCleanisingExercise
- RidesAndFaresExercise
- HourlyTipsExerxise
- ExpiringStateExercise
  
Решения могут быть выполнены на двух языках: Java или Scala. Каждому заданию соответствует .java или .scala файл с шаблоном решения и файл с тестом решения. Тесты расположены в папке test.

### Решение

Лабораторная работа была реализована на языке Java  с использованием более новой версии репозитория (поскольку базовый код из старого репозитория не компилировался из-за отсутствующих зависимостей в удаленном репозитории зависимостей): https://github.com/ververica/flink-training. Отсутствующее в новом репозитории задание ExpiringStateExercise было заменено на LongRidesExercise, поскольку соответствует той же теме.

##### RideCleansingExercise
Задача: оставить поездки, совершенные в пределах Нью Йорка.

![image](https://github.com/VadimKolodin/bigData/assets/105828231/18f64f7f-5a39-4d7b-8804-840ad776f0e8)

В поток данных встраивается фильтр, который при помощи встроенной функции, определяющей, находится ли что-то в переделах Нью Йорка через широту и долготу, проверяет, что поездка начинается и заканчивается в Нью Йорке.

##### RidesAndFaresExercise
Задача: соединить поездки и события начала этой поездки в единый поток.

![image](https://github.com/VadimKolodin/bigData/assets/105828231/de3f046e-6975-498b-954c-d85c81150ab3)
![image](https://github.com/VadimKolodin/bigData/assets/105828231/f9096679-9c5d-4729-9140-9d6a635242e2)
![image](https://github.com/VadimKolodin/bigData/assets/105828231/f9fdd5dd-1aad-4ac1-91ff-ed5990b5ac45)

Для начала все события отфильтровываются так, чтобы остались только события о начале поездки. Далее каждый из потоков помечается ключом, равным идентификатору поездки и соединяются в один поток, поле чего обрабатываются соединяющей функцией. 

Соединяющая функция умеет обрабатывать как объект поездки, так и объект события. Каждая из функций (которая создается для каждого ключа) хранит в себе либо поездку, либо событие. При обработке в ней события/поездки в первый раз, функция сохраняет в себе событие/поездку. При второй обработке (с таким же ключом) можно с уверенностью сказать, что на данный раз обрабатывается поездка/событие, а значит их можно объединить и сложить в выходящий поток.

##### HourlyTipsExercise
Задача: для каждого часа найти водителя с наибольшими чаевыми

![image](https://github.com/VadimKolodin/bigData/assets/105828231/ed5fe0ef-a160-45a0-bda9-da2af4e9c265)

Потоку с оплатой поездок назначаются временные метки, зависящие от даты совершения оплаты, для последующего функционирования оконных функций.
Далее объектам в потоке назначаются ключи, зависящие от идентификатора водителя. После этого поток разбивается на временные окна по идентификатору поездки длительностью в один час и к каждому ключу в окне (то есть водителю) применяется функция, которая складывает все чаевые за поездки. Далее применяется еще одна разбивка на временные окна с длительностью в час, но уже без учета ключа и через функцию редукции выбирается водитель с наибольшими чаевыми.

##### LongRidesExercise
Задача: получить поездки, чья длительность превышает 2 часа. В качестве изначальных данных представлены события начала и окончания поездки. Гарантируется, что для каждого конца поездки присутствует начало (обратное не верно) и нет дублирующихся записей. 

![image](https://github.com/VadimKolodin/bigData/assets/105828231/75ea7911-f1b0-42d8-8961-6eeeaa7031f6)
![image](https://github.com/VadimKolodin/bigData/assets/105828231/04d74621-0a36-463a-b390-543c349e55ef)
![image](https://github.com/VadimKolodin/bigData/assets/105828231/8b3fef49-bc97-4a28-b262-feeeb75223e3)

Потоку с событиями назначаются временные метки и каждому объекту назначается ключ - идентификатор поездки. Далее к потоку применяется функция AlertFunction, находящая поездки, которые длятся более двух часов. Данная функция хранит состояние первого полученного события (соответствующего ее ключу). 
Если объект данной функции ее не получал событие – он его сохраняет и, если событие – начало поездки, устанавливает запланированную функцию, которая сначала положит в поток слишком долгую поездку, а далее очистит поля текущей функции. 
Если объект функции не первый полученный (то есть функция хранит в себе состояние – ранее полученное событие), то проверяется, соответствует ли данная поездка минимальной длительности для предупреждения и складывает в выходной поток, если лимит по времени был превышен. Далее в любом случае состояние очищается, а ранее назначенная запланированная функция сбрасывается.

