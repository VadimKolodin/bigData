# Лабораторная работа 3

### Задание
Выполнить следующие задания из набора заданий репозитория https://github.com/ververica/flink-training-exercises:

RideCleanisingExercise
RidesAndFaresExercise
HourlyTipsExerxise
ExpiringStateExercise
Решения могут быть выполнены на двух языках: Java или Scala. Каждому заданию соответствует .java или .scala файл с шаблоном решения и файл с тестом решения. Тесты расположены в папке test.

### Решение

Лабораторная работа была реализована на языке Java  с использованием более новой версии репозитория (поскольку базовый код из старого репозитория не компилировался из-за отсутствующих зависимостей в удаленном репозитории зависимостей): https://github.com/ververica/flink-training. Отсутствующее в новом репозитории задание ExpiringStateExercise было заменено на LongRidesExercise, поскольку соответствует той же теме.

##### RideCleansingExercise
Задача: оставить поездки, совершенные в пределах Нью Йорка.

В поток данных встраивается фильтр, который при помощи встроенной функции, определяющей, находится ли что-то в переделах Нью Йорка через широту и долготу, проверяет, что поездка начинается и заканчивается в Нью Йорке.

##### RidesAndFaresExercise
Задача: соединить поездки и события начала этой поездки в единый поток.

Для начала все события отфильтровываются так, чтобы остались только события о начале поездки. Далее каждый из потоков помечается ключом, равным идентификатору поездки и соединяются в один поток, поле чего обрабатываются соединяющей функцией. 
Соединяющая функция умеет обрабатывать как объект поездки, так и объект события. Каждая из функций (которая создается для каждого ключа) хранит в себе либо поездку, либо событие. При обработке в ней события/поездки в первый раз, функция сохраняет в себе событие/поездку. При второй обработке (с таким же ключом) можно с уверенностью сказать, что на данный раз обрабатывается поездка/событие, а значит их можно объединить и сложить в выходящий поток.

##### HourlyTipsExercise
Задача: для каждого часа найти водителя с наибольшими чаевыми

Потоку с оплатой поездок назначаются временные метки, зависящие от даты совершения оплаты, для последующего функционирования оконных функций.
Далее объектам в потоке назначаются ключи, зависящие от идентификатора водителя. После этого поток разбивается на временные окна по идентификатору поездки длительностью в один час и к каждому ключу в окне (то есть водителю) применяется функция, которая складывает все чаевые за поездки. Далее применяется еще одна разбивка на временные окна с длительностью в час, но уже без учета ключа и через функцию редукции выбирается водитель с наибольшими чаевыми.


##### LongRidesExercise
Задача: получить поездки, чья длительность превышает 2 часа. В качестве изначальных данных представлены события начала и окончания поездки. Гарантируется, что для каждого конца поездки присутствует начало (обратное не верно) и нет дублирующихся записей. 

Потоку с событиями назначаются временные метки и каждому объекту назначается ключ - идентификатор поездки. Далее к потоку применяется функция AlertFunction, находящая поездки, которые длятся более двух часов. Данная функция хранит состояние первого полученного события (соответствующего ее ключу). 
Если объект данной функции ее не получал событие – он его сохраняет и, если событие – начало поездки, устанавливает запланированную функцию, которая сначала положит в поток слишком долгую поездку, а далее очистит поля текущей функции. 
Если объект функции не первый полученный (то есть функция хранит в себе состояние – ранее полученное событие), то проверяется, соответствует ли данная поездка минимальной длительности для предупреждения и складывает в выходной поток, если лимит по времени был превышен. Далее в любом случае состояние очищается, а ранее назначенная запланированная функция сбрасывается.

